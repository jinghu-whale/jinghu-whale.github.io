<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="suda masaki hahaha">
<meta property="og:type" content="website">
<meta property="og:title" content="HJ&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="HJ&#39;s Blog">
<meta property="og:description" content="suda masaki hahaha">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HJ&#39;s Blog">
<meta name="twitter:description" content="suda masaki hahaha">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>HJ's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HJ's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/27/Eclipse学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="whale">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HJ's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/27/Eclipse学习/" itemprop="url">Eclipse学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-27T19:02:47+08:00">
                2019-12-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Eclipse学习"><a href="#Eclipse学习" class="headerlink" title="Eclipse学习"></a>Eclipse学习</h1><p><a name="Ahd9o"></a></p>
<h2 id="缩写含义"><a href="#缩写含义" class="headerlink" title="缩写含义"></a>缩写含义</h2><p>SWT 标准窗口小部件工具箱——用来生成本地化风格的用户交互界面组件，拥有独立于操作系统的API<br>JFace 基于SWT 提供对常用UI任务的支持；<br>JDT Java开发工具<br>PDE 插件开发环境——PDE提供自动创建、处理、调试和部署插件的工具；</p>
<p>Eclipse平台允许任何人构建与环境和其他环境无缝集成的工具。工具与Eclipse无缝集成的关键是插件。除了小型的运行时内核之外，Eclipse中的所有东西都是插件。<br>如图所示，Workbench和Workspace是Eclipse平台两个必备的插件——它们提供了大多数插件使用的扩展点，插件需要扩展点菜可以插入，这样才能运行。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/436186/1565921181473-9e542633-e479-47a8-8e27-8fd788e3a447.png#align=left&display=inline&height=274&name=image.png&originHeight=274&originWidth=393&size=22256&status=done&style=none&width=393" alt="image.png"><br>Debug组件 可以让插件启动程序、与正在运行的程序交互，以及处理错误——这是构建调试器所必需的。<br>Team组件 允许 Eclipse 资源与版本控制系统（VCS）交互。<br>Help组件 提供应用程序的联机文档和与上下文敏感的帮助。</p>
<p><a name="yMtlL"></a></p>
<h2 id="创建插件"><a href="#创建插件" class="headerlink" title="创建插件"></a>创建插件</h2><p>使用Plug-in Development Environment（PDE）。PDE 和 Java Development Tooling（JDT）IDE 是 Eclipse 的标准扩展。PDE 提供了一些向导以帮助创建插件。<br>PDE的界面里，工作台是向导创造的一些文件：包含项目类路径中的许多.jar文件（里面包含插件和Java运行时所需的Eclipse类），一个图标文件夹icons（包含了工具栏按钮的图形），以及bulid.properties文件（包含自动构建脚本所使用的变量），src文件夹里面包含了插件和plugin.xml文件的源代码。</p>
<p>plugin.xml包含了Eclipse将插件集成到框架所使用的描述信息。<br>插件释义：</p>
<p><code>org.eclipse.core.resources</code> 是工作区插件<br><code>org.eclipse.ui</code> 是工作台</p>
<p>如果你要在插件上增加扩展点，用extension标记。操作集合是插件添加到工作台用户界面的一组基值——菜单、菜单栏和工具栏。操作集合分组了基值，这样用户可以更方便地管理。</p>
<p>完成所有的操作后代码生成向导会生成两个java源文件，在src里。<br>第一个xxPlugin.java是插件类，负责管理插件的生命周期，可能还负责维护对话框设置和用户首选项等内容。<br>第二个为sampleAction.java。包含执行在清单文件的操作集合中指定的操作类。<br>（清单文件就是manifest file文件，是jar档案中包含的特殊文件。jar文件用于聚合大量的Java类文件、相关元数据和资源，一个jar文件允许java运行时高效地部署一组类和它们相关的资源，启动的话需要manifest.mf。如果jar文件被用作可执行地应用程序，任意包含<code>public static void main(String[] args)</code>方法的类即为java虚拟机入口点点位置）。<br>清单文件Manifest.MF，标记插件并提供依赖关系信息，其内容包含：<br>必须的套件：与其他插件的依赖关系<br>导出的包：使该插件对其他插件可见的包<br>插件轻但文件名为Plugin.xml，声明到其他插件的相互连接，该文件可以定义：<br>扩展点：用于其他插件的功能的声明<br>扩展：其他插件扩展点的用法（实现）</p>
<p><a name="qXPM4"></a></p>
<h2 id="运行和调试插件"><a href="#运行和调试插件" class="headerlink" title="运行和调试插件"></a>运行和调试插件</h2><p><a name="gL1ht"></a></p>
<h2 id="EMF建模"><a href="#EMF建模" class="headerlink" title="EMF建模"></a>EMF建模</h2><p>EMF是Eclipse建模项目的核心，提供基本功能如模型转换、数据库集成和图形编辑器生成等。<br>EMF统一了Java、XML和UML这三种表示。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/436186/1573717456896-fee63b03-07d9-45e7-a630-e94b2835b14d.png#align=left&display=inline&height=191&name=image.png&originHeight=191&originWidth=303&size=13293&status=done&style=none&width=303" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2019/png/436186/1573722071082-17bbe71e-8622-48f3-ac01-c1655d906da6.png#align=left&display=inline&height=227&name=image.png&originHeight=227&originWidth=512&size=32490&status=done&style=none&width=512" alt="image.png"></p>
<p>EClass用来表示建模类。有名称、0个或多个属性、0个或多个引用；<br>EAttribute用来表示模型属性，属性有名称和类型；<br>EReference用来表示类之间关联的一端。有名称还有引用目标类型。<br>EDataType用来表示属性的类型。数据类型可能是基本类型或对象类型。<br>EObject是相当于java.lang.Object的EMF对等物，是所有模型化对象的基础。</p>
<p>XMI串行化（XML Metadata Interchange,XMI) XML元数据互换</p>
<p><a href="https://baike.baidu.com/item/XML" target="_blank" rel="noopener">XML</a>元数据交换(XML Metadata Interchange)，简称XMI，是由OMG组织开发的，它是统一建模语言<a href="https://baike.baidu.com/item/UML/446747" target="_blank" rel="noopener">UML</a>模型中元数据的标准交换方式。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/436186/1573721595612-07bfb0fe-a89f-4ee8-ae40-68a4817d778e.png#align=left&display=inline&height=202&name=image.png&originHeight=202&originWidth=531&size=64360&status=done&style=none&width=531" alt="image.png"></p>
<p><a name="U0zJP"></a></p>
<h3 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h3><p>Ecore模型 元模型的模型，定义元模型的基本属性。Ecore和XMI串行化是EMF的核心。Java实现代码或者模型的其他形式可以从Ecore模型生成。（Ecore中保存有生成的类及名称、属性、引用，然而对于生成代码的话还缺少保存在何处，生成的factory和package名称使用什么前缀等等）<br>所以这个问题是通过EMF生成器模型来解决的。生成器模型保存这些信息，本身也是EMF模型。实际上就是EMF生成的编辑器。</p>
<p>为模型生成的两个重要类：工厂（factory)类和包（package）类。生成的工厂包含模型中每个类的方法，EMF建议使用工厂创建对象。可为模型的所有Ecore元数据提供便利的存取器。</p>
<p>EMF生成代码：使用EMF项目向导创建一个项目，将自动启动生成器，然后从菜单中选择Generate Model Code命令。<br>EMF生成器还可以根据需要生成：</p>
<ul>
<li>模型的框架适配器工厂类（POAdapterFactory）</li>
<li>便利的转换类（POSwitch）</li>
<li>插件清单文件和属性文件，从而使模型可用作Eclipse插件</li>
</ul>
<p>不过EMF生成器生成的文件是生成文件和手动编写文件的组合，需要编辑生成的类来添加方法和实例变量。可以一直从模型中生成，在重新生成的过程中会保存添加的内容。这些被生成的代码字段都会被@generate标记。</p>
<p><a name="qG58p"></a></p>
<h2 id="使用EMF-Edit编辑模型"><a href="#使用EMF-Edit编辑模型" class="headerlink" title="使用EMF.Edit编辑模型"></a>使用EMF.Edit编辑模型</h2><p>eclipse还提供了EMF.Edit为模型构建查看器和编辑器，可以生成一个使用JFace查看器的属性表显示和编辑模型的实例。<br>EMF.Edit包含一组用于修改EMF对象的通用命令，这些命令扩展在公共命令组件中定义的接口并建立在这些解耦之上，使用反射EObject API来操作对象，并实施对Ecore 的依赖关系。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/436186/1574003049676-713a80e4-134a-49ea-aa6c-7cccd39b8b91.png#align=left&display=inline&height=78&name=image.png&originHeight=156&originWidth=591&size=51119&status=done&style=none&width=295.5" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/436186/1574003068217-8e77d748-cb7e-436b-9fdc-a8bcaf6006e7.png#align=left&display=inline&height=155&name=image.png&originHeight=309&originWidth=764&size=109788&status=done&style=none&width=382" alt="image.png"></p>
<p>EMF可以通过几种形式来使用模型定义，并为它生成Java实现代码。如果给定相同的模型定义，也可以使用EMF.Edit代码生成支持 来生成项提供程序和编辑模型实例所需的其他类，EMF.Edit不是一个单独的工具，是模型生成器的另一种也行。生成模型之后，可以通过Generate Edit Code和Generate Editor Code菜单项来生成EMF.Edit部分。<br><a name="wVoPb"></a></p>
<h2 id="使用EMF的流程"><a href="#使用EMF的流程" class="headerlink" title="使用EMF的流程"></a>使用EMF的流程</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/436186/1574003470341-bc6dc012-ca7f-4710-80e3-f35212995599.png#align=left&display=inline&height=307&name=image.png&originHeight=280&originWidth=369&size=45764&status=done&style=none&width=404" alt="image.png"><br>一个简单的采购订单的UML模型，图中显示了类、属性、引用、互相间的关系。</p>
<p>因为EMF模型驻留在一个插件中，而编辑器独立于UI和UI相关的部分驻留在另外两个插件中。所以EMF开发工具将基于JDT和PDE并与它们一起使用。EMF项目有java的清单文件，但特别在与还包含（生成器模型文件（.genmodel) Ecore模型文件（.ecore)</p>
<p>新建EMF模型 （选择合适的模型导入器，包括 注释的java代码，类图，ecore模型（已有ecore模型 导入它创建生成器模型），xml文件），这个向导为模型创建Ecore和生成器模型。</p>
<p>（（从特定模型格式转换到Ecore这种机制，是通过扩展模型导入器扩展点org.eclipse.emf.importer.modelImporterDescriptors)已支持这种格式。</p>
<p>生成模型和编辑器插件的代码之后，使用这些插件来创建和编辑模型的实例。</p>
<p><a name="TCBNA"></a></p>
<h3 id="XML-Schema"><a href="#XML-Schema" class="headerlink" title="XML Schema"></a>XML Schema</h3><p>EMF提供了一种基于XML Schema的方法，可以通过创建一个对象模型来操作某种类型的XML数据结构。EMF创建一个对应于某种模式的Ecore模型，从而我们可以利用代码生成器或者动态EMF来提供一个用于操作该模型实例的jAVA api。</p>
<p>在建模的角度看，XML不太具有表现力，不能用来定义双向引用，或者提供引用目标的类型。为了解决这个问题，EMF以来自Ecore名称空间的属性的形式提供一组到XML的扩展，用来指定这些遗漏的信息。xml schema主要是定义xml实例文档的结构，可以被串行化为XML。（    XMI）信息来源于eclipse/emf/ecore/util/ExtendedMetaData.</p>
<p>EMF的核心价值是其生成高质量代码的能力。另外EMF代码生成其的可配置性很强，使用户对它生成的模型和编辑器实现有很大的控制权。</p>
<p>代码生成基于Ecore模型，生成直接对应于这种模型内定义的包、类和枚举类型的类；这些生成的类的成员基于属性、引用、操作和枚举字面值。<br>生成文件包含两个步骤：首先，内容是由一个模板驱动的引擎——JET或者java发射器模板（java emitter tamplates）生成，引擎将每个模板转换为将混合固定模板数据和回调对应于具体模型的结果的java类源代码；之后它将编译、动态加载、并使用这些类来发射期望的内容。第二步，一个源文件合并实用程序（JMerge）将发射的内容合并到预存在的文件中，基于@generated javadoc标记<br><img src="https://cdn.nlark.com/yuque/0/2019/png/436186/1574005259004-a8cab569-60e9-4170-9425-c2791a6763a6.png#align=left&display=inline&height=373&name=image.png&originHeight=746&originWidth=1002&size=177614&status=done&style=none&width=501" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2019/png/436186/1574005265619-e6d2bbac-a7c0-4a5e-8349-ddf83eed0c99.png#align=left&display=inline&height=167&name=image.png&originHeight=334&originWidth=1009&size=106735&status=done&style=none&width=504.5" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/436186/1574005280658-df63509d-7bc4-4a6c-b844-bf9fbb3cc485.png#align=left&display=inline&height=174&name=image.png&originHeight=347&originWidth=985&size=75057&status=done&style=none&width=492.5" alt="image.png"><br><a name="TiQht"></a></p>
<h2 id="Eclipse各文件的含义"><a href="#Eclipse各文件的含义" class="headerlink" title="Eclipse各文件的含义"></a>Eclipse各文件的含义</h2><p>plugin.xml文件配置（菜单，工具栏，弹出菜单）<br>menu配置eclipse菜单栏；<br>toolbar配置eclipse工具栏；<br>popupMenus配置鼠标右击弹出菜单；</p>
<p>一个可以被eclipse安装的插件需要包含<em>.jar文件（有一个继承AbstractUIPlugin的插件类）、清单文件以及所需的资源。含两个文件夹 fetures和plugins。<br>links文件夹里，</em>.link文件是链接文件，每个链接文件都指向一个产品扩展位置。eclipse启动时会自动扫描这个文件夹去寻找插件并安装。（不是必须）<br>myplugin中存放自己开发的插件<br>workspace是默认工程目录<br>otherplugin中存放一些需要管理的插件，每一个插件文件夹里都包含一个eclipse，eclipse文件夹里包含features，plugins和一个空文件*.eclipseextension。<br>target中存放eclipse rcp sdk解压后的文件</p>
<p><a name="pWnB1"></a></p>
<h3 id="Plugin-xml文件"><a href="#Plugin-xml文件" class="headerlink" title="Plugin.xml文件"></a>Plugin.xml文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- url指定插件主页的url（也可从Plugins设置里打开）--&gt;&lt;br /&gt;&lt;idea-plugin url=&quot;https://www.jetbrains.com/idea&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;!-- 插件名称--&gt;&lt;br /&gt;  &lt;name&gt;VssIntegration&lt;/name&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;!--插件的唯一标识符，如果没有指定默认为name，但会导致一些脆弱的结果 --&gt;&lt;br /&gt;  &lt;id&gt;com.jetbrains.vssintegration&lt;/id&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;!--插件的描述，要简单明了 。&lt;br /&gt;      对于添加语言/平台/框架支持的插件，要指定这些的版本--&gt;&lt;br /&gt;  &lt;description&gt;Integrates Volume Snapshot Service W10&lt;/description&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;!-- 描述插件最新版本的变化--&gt;&lt;br /&gt;  &lt;change-notes&gt;Initial release of the plugin.&lt;/change-notes&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;!-- 插件的版本  --&gt;&lt;br /&gt;   &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;!-- 插件的供应商--&gt;&lt;br /&gt;   &lt;vendor url=&quot;https://www.jetbrains.com&quot; email=&quot;support@jetbrains.com&quot;&gt;A Company Inc.&lt;/vendor&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;!--对其他插件或模块的强制性依赖 。&lt;br /&gt;      &lt;depend&gt;中的FQN模块名用于确定插件的IDE兼容性  --&gt;</span><br><span class="line">  &lt;depends&gt;com.intellij.modules.platform&lt;/depends&gt;&lt;br /&gt;  &lt;depends&gt;com.third.party.plugin&lt;/depends&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;!-- 可选的依赖的另一个插件。&lt;br /&gt;       如果这个插件的&quot;com.MySecondPlugin&quot; ID 被安装, &lt;br /&gt;       那么这个mysecondplugin.xml会被加载. --&gt;&lt;br /&gt;  &lt;depends optional=&quot;true&quot; config-file=&quot;mysecondplugin.xml&quot;&gt;com.MySecondPlugin&lt;/depends&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;!-- 与插件兼容的IDE的最小和最大构建--&gt;&lt;br /&gt;  &lt;idea-version since-build=&quot;183&quot; until-build=&quot;183.*&quot;/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;!-- 资源包 (/messages/MyPluginBundle.properties)在扩展点和隐藏键被key属性使用 &lt;br /&gt;        like</span><br><span class="line">       `action.[pluginID].[ActionID].text` --&gt;&lt;br /&gt;  &lt;resource-bundle&gt;messages.MyPluginBundle&lt;/resource-bundle&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;!-- 插件的应用程序组件 --&gt;&lt;br /&gt;  &lt;application-components&gt;&lt;br /&gt;</span><br><span class="line">    &lt;component&gt;&lt;br /&gt;      &lt;!-- 组件的接口类 --&gt;&lt;br /&gt;      &lt;interface-class&gt;com.foo.Component1Interface&lt;/interface-class&gt;&lt;br /&gt;</span><br><span class="line">      &lt;!-- 组件的实现类 --&gt;&lt;br /&gt;      &lt;implementation-class&gt;com.foo.impl.Component1Impl&lt;/implementation-class&gt;&lt;br /&gt;</span><br><span class="line">    &lt;/component&gt;&lt;br /&gt;</span><br><span class="line">  &lt;/application-components&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;!-- 插件的项目组件 --&gt;&lt;br /&gt;  &lt;project-components&gt;&lt;br /&gt;    &lt;component&gt;&lt;br /&gt;      &lt;!--接口和实现类是一样的 --&gt;&lt;br /&gt;</span><br><span class="line">      &lt;implementation-class&gt;com.foo.Component2&lt;/implementation-class&gt;&lt;br /&gt;&lt;!--如果workspace选项设置为ture，那么组件会将其状态保存到.iws文件中&lt;br /&gt;      而不是保存到.ipr文件中。&lt;br /&gt;      注意，只有在组件实现JDOMExternalizable接口时才使用&lt;option&gt;element。&lt;br /&gt;      否则，使用&lt;option&gt;将不起作用--&gt;&lt;br /&gt;      &lt;option name=&quot;workspace&quot; value=&quot;true&quot; /&gt;&lt;br /&gt;</span><br><span class="line">      &lt;!-- 如果存在 &quot;loadForDefaultProject&quot; 标记，则也为默认项目实例化项目组件。--&gt;&lt;br /&gt;</span><br><span class="line">      &lt;loadForDefaultProject/&gt;&lt;br /&gt;    &lt;/component&gt;&lt;br /&gt;  &lt;/project-components&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;!-- 插件的模块组件 --&gt;&lt;br /&gt;  &lt;module-components&gt;&lt;br /&gt;    &lt;component&gt;&lt;br /&gt;      &lt;implementation-class&gt;com.foo.Component3&lt;/implementation-class&gt;&lt;br /&gt;    &lt;/component&gt;&lt;br /&gt;  &lt;/module-components&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;!-- Actions --&gt;&lt;br /&gt;  &lt;actions&gt;&lt;br /&gt;</span><br><span class="line">    &lt;action id=&quot;VssIntegration.GarbageCollection&quot; class=&quot;com.foo.impl.CollectGarbage&quot; text=&quot;Collect _Garbage&quot; description=&quot;Run garbage collector&quot;&gt;&lt;br /&gt;      &lt;keyboard-shortcut first-keystroke=&quot;control alt G&quot; second-keystroke=&quot;C&quot; keymap=&quot;$default&quot;/&gt;&lt;br /&gt;</span><br><span class="line">    &lt;/action&gt;&lt;br /&gt;</span><br><span class="line">  &lt;/actions&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;!-- 插件定义的扩展点。&lt;br /&gt;       扩展点由插件注册，这样其他插件可为这个插件提供需要的数据。&lt;br /&gt;       &quot;beanClass&quot;属性指定可用于扩展点的实现的类。--&gt;&lt;br /&gt;  &lt;extensionPoints&gt;&lt;br /&gt;    &lt;extensionPoint name=&quot;testExtensionPoint&quot; beanClass=&quot;com.foo.impl.MyExtensionBean&quot;/&gt;&lt;br /&gt;</span><br><span class="line">  &lt;/extensionPoints&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;!-- 插件添加到IntelliJ平台或其他插件定义的扩展点上的扩展。 &lt;br /&gt;       &quot;defaultExtensionNs &quot;属性必须设置为定义扩展点的插件的ID，&lt;br /&gt;        或者设置为&quot;com.intellij&quot; （如果扩展点是由IntelliJ平台定义的）. &lt;br /&gt;        &lt;extensions&gt;标记中的标记名称与扩展点的名称匹配，&lt;br /&gt;         而 &quot;implementation&quot;类指定添加到扩展点的类的名称. --&gt;&lt;br /&gt;  &lt;extensions xmlns=&quot;VssIntegration&quot;&gt;&lt;br /&gt;    &lt;testExtensionPoint implementation=&quot;com.foo.impl.MyExtensionImpl&quot;/&gt;&lt;br /&gt;  &lt;/extensions&gt;&lt;br /&gt;&lt;/idea-plugin&gt;</span><br></pre></td></tr></table></figure>

<p><a name="6JqKZ"></a></p>
<h2 id="Eclipse插件开发"><a href="#Eclipse插件开发" class="headerlink" title="Eclipse插件开发"></a>Eclipse插件开发</h2><p>（以一个开发实例为例，这个插件是通过插件模板中的视图模板来创建的。<br>file——new——plug-in project 然后命名要以org.eclipse.ui这种类型的方式，本例为com.plugindev.addressbook)<br><img src="https://cdn.nlark.com/yuque/0/2019/png/436186/1574325644109-eef8af15-57e3-4844-bd21-fd6901e7e111.png#align=left&display=inline&height=992&name=image.png&originHeight=992&originWidth=1288&size=118048&status=done&style=none&width=1288" alt="image.png"><br>中间这个界面是PDE提供的一个基于表单的多页插件清单编辑器。打开这个新建的插件，可以看到，最底下包含”概述”“依赖性”“运行时”“扩展”“扩展点”“构建”“MANIFEST.MF”,plugin.xml,bulid.properties 9个页面，用来编辑插件的各种清单文件。</p>
<p>下图为概述界面。提供了对插件的一般信息和执行环境的编辑，可以定义和修改插件的基本属性。<br>general information中依次有 标识、版本、名称、提供程序等等。并在OSGi清单文件（MANIFEST.MF)中有对应项，两个地方都可编辑 是一样的。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/436186/1574327058585-1bf4c7d4-0368-4261-9da1-a3da038e525a.png#align=left&display=inline&height=714&name=image.png&originHeight=714&originWidth=717&size=76511&status=done&style=none&width=717" alt="image.png"><br>调整JRE库，启动插件，插件的导出设置等等。</p>
<p>通过MANIFEST.MF、plugin.xml和bulid.properties统一管理所有插件文件。</p>
<p><a name="xj8dm"></a></p>
<h3 id="plugin-xml"><a href="#plugin-xml" class="headerlink" title="plugin.xml"></a>plugin.xml</h3><p>plugin.xml文件是用来记录插件的扩展点和扩展的。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/436186/1574386625902-7363a803-b632-4c67-aae1-9ea626c701ab.png#align=left&display=inline&height=702&name=image.png&originHeight=702&originWidth=827&size=74518&status=done&style=none&width=827" alt="image.png"></p>
<ul>
<li><plugin>元素定义清单的主体。可以有选择地包含由该插件引入的任何新扩展点的声明以及功能扩展的配置。</plugin></li>
<li><extension>定义该插件对其他插件的功能扩展，具有point（所引用扩展点的标识）、id（本实例的名字）、name（扩展提供给用户的名称，就是可视的，在本实例中相当于view中拉出来的栏目中可视化的名称为地址视图）</extension></li>
<li><extension-point>扩展点 这个例子中没有扩展点。</extension-point></li>
</ul>
<p><a name="84BAs"></a></p>
<h3 id="MANIFEST-MF"><a href="#MANIFEST-MF" class="headerlink" title="MANIFEST.MF"></a>MANIFEST.MF</h3><p>MANIFEST.MF是用来提供关于捆绑软件的描述信息。<br>可以在这个页面编辑，也可以在overview和dependencies视图中修改。<br>require-bundle就是依赖的其他插件 与依赖项视图中的对应。修改的话修改一边，另一个地方会自动改。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/436186/1574388872641-003a2cae-2647-4933-a54b-51539e945f81.png#align=left&display=inline&height=323&name=image.png&originHeight=323&originWidth=656&size=25417&status=done&style=none&width=656" alt="image.png"></p>
<p><a name="IcDR7"></a></p>
<h3 id="build-properties文件"><a href="#build-properties文件" class="headerlink" title="build.properties文件"></a>build.properties文件</h3><p>bulid.properties文件记录了需要构建的元素的列表，PDE（插件开发环境）通过这个文件构建插件，最终构建的插件中不需要再包含这个文件。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/436186/1574389676858-2e88417d-b255-4164-bc37-689b12ac32ea.png#align=left&display=inline&height=230&name=image.png&originHeight=230&originWidth=353&size=9471&status=done&style=none&width=353" alt="image.png"><br>具体地说，应该就是插件生成的代码文件要放到对应的什么文件夹里，都是这个properties定义的。同样地，也可以在Build视图中修改，改了一边另一边会自动修改。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/436186/1574390193884-f23f0cf4-570d-4ed9-9363-5598539c0689.png#align=left&display=inline&height=366&name=image.png&originHeight=366&originWidth=801&size=23579&status=done&style=none&width=801" alt="image.png"><br>打勾的项表示二进制目录中包括的资源。如果插件依赖于额外的资源，一定要包含再构建路径中。</p>
<p><a name="CpN6T"></a></p>
<h2 id="对应Java代码"><a href="#对应Java代码" class="headerlink" title="对应Java代码"></a>对应Java代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">package com.plugindev.addressbook.views;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import org.eclipse.swt.widgets.Composite;</span><br><span class="line">import org.eclipse.ui.part.*;</span><br><span class="line">import org.eclipse.jface.viewers.*;</span><br><span class="line">import org.eclipse.swt.graphics.Image;</span><br><span class="line">import org.eclipse.jface.action.*;</span><br><span class="line">import org.eclipse.jface.dialogs.MessageDialog;</span><br><span class="line">import org.eclipse.ui.*;</span><br><span class="line">import org.eclipse.swt.widgets.Menu;</span><br><span class="line">import org.eclipse.swt.SWT;</span><br><span class="line">import javax.inject.Inject;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * This sample class demonstrates how to plug-in a new</span><br><span class="line"> * workbench view. The view shows data obtained from the</span><br><span class="line"> * model. The sample creates a dummy model on the fly,</span><br><span class="line"> * but a real implementation would connect to the model</span><br><span class="line"> * available either in this or another plug-in (e.g. the workspace).</span><br><span class="line"> * The view is connected to the model using a content provider.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * The view uses a label provider to define how model</span><br><span class="line"> * objects should be presented in the view. Each</span><br><span class="line"> * view can present the same model objects using</span><br><span class="line"> * different labels and icons, if needed. Alternatively,</span><br><span class="line"> * a single label provider can be shared between views</span><br><span class="line"> * in order to ensure that objects of the same type are</span><br><span class="line"> * presented in the same way everywhere.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class AddressView extends ViewPart &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * The ID of the view as specified by the extension.</span><br><span class="line">	 */</span><br><span class="line">	public static final String ID = &quot;com.plugindev.addressbook.views.AddressView&quot;;</span><br><span class="line"></span><br><span class="line">	@Inject IWorkbench workbench;</span><br><span class="line">	</span><br><span class="line">	private TableViewer viewer;</span><br><span class="line">	private Action action1;</span><br><span class="line">	private Action action2;</span><br><span class="line">	private Action doubleClickAction;</span><br><span class="line">	 </span><br><span class="line"></span><br><span class="line">	class ViewLabelProvider extends LabelProvider implements ITableLabelProvider &#123;</span><br><span class="line">		@Override</span><br><span class="line">		public String getColumnText(Object obj, int index) &#123;</span><br><span class="line">			return getText(obj);</span><br><span class="line">		&#125;</span><br><span class="line">		@Override</span><br><span class="line">		public Image getColumnImage(Object obj, int index) &#123;</span><br><span class="line">			return getImage(obj);</span><br><span class="line">		&#125;</span><br><span class="line">		@Override</span><br><span class="line">		public Image getImage(Object obj) &#123;</span><br><span class="line">			return workbench.getSharedImages().getImage(ISharedImages.IMG_OBJ_ELEMENT);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void createPartControl(Composite parent) &#123;</span><br><span class="line">		viewer = new TableViewer(parent, SWT.MULTI | SWT.H_SCROLL | SWT.V_SCROLL);</span><br><span class="line">		</span><br><span class="line">		viewer.setContentProvider(ArrayContentProvider.getInstance());</span><br><span class="line">		viewer.setInput(new String[] &#123; &quot;One&quot;, &quot;Two&quot;, &quot;Three&quot; &#125;);</span><br><span class="line">	viewer.setLabelProvider(new ViewLabelProvider());</span><br><span class="line"></span><br><span class="line">		// Create the help context id for the viewer&apos;s control</span><br><span class="line">		workbench.getHelpSystem().setHelp(viewer.getControl(), &quot;com.plugindev.addressbook.viewer&quot;);</span><br><span class="line">		getSite().setSelectionProvider(viewer);</span><br><span class="line">		makeActions();</span><br><span class="line">		hookContextMenu();</span><br><span class="line">		hookDoubleClickAction();</span><br><span class="line">		contributeToActionBars();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private void hookContextMenu() &#123;</span><br><span class="line">		MenuManager menuMgr = new MenuManager(&quot;#PopupMenu&quot;);</span><br><span class="line">		menuMgr.setRemoveAllWhenShown(true);</span><br><span class="line">		menuMgr.addMenuListener(new IMenuListener() &#123;</span><br><span class="line">			public void menuAboutToShow(IMenuManager manager) &#123;</span><br><span class="line">				AddressView.this.fillContextMenu(manager);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		Menu menu = menuMgr.createContextMenu(viewer.getControl());</span><br><span class="line">		viewer.getControl().setMenu(menu);</span><br><span class="line">		getSite().registerContextMenu(menuMgr, viewer);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private void contributeToActionBars() &#123;</span><br><span class="line">		IActionBars bars = getViewSite().getActionBars();</span><br><span class="line">		fillLocalPullDown(bars.getMenuManager());</span><br><span class="line">		fillLocalToolBar(bars.getToolBarManager());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private void fillLocalPullDown(IMenuManager manager) &#123;</span><br><span class="line">		manager.add(action1);</span><br><span class="line">		manager.add(new Separator());</span><br><span class="line">		manager.add(action2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private void fillContextMenu(IMenuManager manager) &#123;</span><br><span class="line">		manager.add(action1);</span><br><span class="line">		manager.add(action2);</span><br><span class="line">		// Other plug-ins can contribute there actions here</span><br><span class="line">		manager.add(new Separator(IWorkbenchActionConstants.MB_ADDITIONS));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private void fillLocalToolBar(IToolBarManager manager) &#123;</span><br><span class="line">		manager.add(action1);</span><br><span class="line">		manager.add(action2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private void makeActions() &#123;</span><br><span class="line">		action1 = new Action() &#123;</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				showMessage(&quot;Action 1 executed&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		action1.setText(&quot;Action 1&quot;);</span><br><span class="line">		action1.setToolTipText(&quot;Action 1 tooltip&quot;);</span><br><span class="line">		action1.setImageDescriptor(PlatformUI.getWorkbench().getSharedImages().</span><br><span class="line">			getImageDescriptor(ISharedImages.IMG_OBJS_INFO_TSK));</span><br><span class="line">		</span><br><span class="line">		action2 = new Action() &#123;</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				showMessage(&quot;Action 2 executed&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		action2.setText(&quot;Action 2&quot;);</span><br><span class="line">		action2.setToolTipText(&quot;Action 2 tooltip&quot;);</span><br><span class="line">		action2.setImageDescriptor(workbench.getSharedImages().</span><br><span class="line">				getImageDescriptor(ISharedImages.IMG_OBJS_INFO_TSK));</span><br><span class="line">		doubleClickAction = new Action() &#123;</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				IStructuredSelection selection = viewer.getStructuredSelection();</span><br><span class="line">				Object obj = selection.getFirstElement();</span><br><span class="line">				showMessage(&quot;Double-click detected on &quot;+obj.toString());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private void hookDoubleClickAction() &#123;</span><br><span class="line">		viewer.addDoubleClickListener(new IDoubleClickListener() &#123;</span><br><span class="line">			public void doubleClick(DoubleClickEvent event) &#123;</span><br><span class="line">				doubleClickAction.run();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	private void showMessage(String message) &#123;</span><br><span class="line">		MessageDialog.openInformation(</span><br><span class="line">			viewer.getControl().getShell(),</span><br><span class="line">			&quot;地址本视图&quot;,</span><br><span class="line">			message);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void setFocus() &#123;</span><br><span class="line">		viewer.getControl().setFocus();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它对应的概览页的插件的动作和函数为：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/436186/1574650979791-e35e3dc0-b2be-4209-a709-71a7c5a90a63.png#align=left&display=inline&height=626&name=image.png&originHeight=626&originWidth=509&size=57525&status=done&style=none&width=509" alt="image.png"></p>
<p><a name="DcoNJ"></a></p>
<h3 id="运行插件程序"><a href="#运行插件程序" class="headerlink" title="运行插件程序"></a>运行插件程序</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/436186/1574402282729-2b33adb5-017c-49b0-9165-188f6cf97959.png#align=left&display=inline&height=702&name=image.png&originHeight=702&originWidth=1056&size=99804&status=done&style=none&width=1056" alt="image.png"><br>然后通过运行这个插件，就生成了eclipse runtime。<br>在这个runtime中 打开windows-show view-other，就会发现比普通的eclipse平台界面多了一个PLUGINDEV，地址本视图。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/436186/1574650038054-de6438bc-0e97-4592-92f3-d8b7d1d77105.png#align=left&display=inline&height=452&name=image.png&originHeight=452&originWidth=345&size=19104&status=done&style=none&width=345" alt="image.png"></p>
<p>open这个地址本视图<br>可以看到依次三个图标。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/436186/1574650048030-a754a62c-3fb3-4677-ac3c-a4fb6a929b95.png#align=left&display=inline&height=493&name=image.png&originHeight=493&originWidth=694&size=19752&status=done&style=none&width=694" alt="image.png"><br>打开任意一个图标，会看到类似的画面（因为没有对图标内容，button操作有什么具体的定义，所以这里简单示例的是一个警告界面）任意过程都是可编程可自定义的。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/436186/1574650316389-4e96dd34-8600-483f-892c-730967418392.png#align=left&display=inline&height=153&name=image.png&originHeight=153&originWidth=522&size=8776&status=done&style=none&width=522" alt="image.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/27/vlog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="whale">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HJ's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/27/vlog/" itemprop="url">分享生活vlog</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-27T14:02:43+08:00">
                2019-12-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前一直有在陆陆续续地剪视频，但只给出镜的几个朋友看过。后来一时兴起传到了b站。然后今天又一时兴起想起了好久没更新的博客。所以打算把生活的一些视频片段也传一传。就当是记录吧。</p>
<p>一直很想输出内容，我仔细思考了一下 应该是很害怕自己总有一天会消失，也害怕自己不留痕迹。在我脑海里那么多快乐的、忧愁的、烦恼的，奇思妙想的很多想法，不想它消失。有时候在微博上或者是博客里看到个人的帐号，总是感觉离那个人很近，大家都是鲜活的，跳跃的生命，所以总期待着不期而遇的惊喜，也期待着一些奇妙连接。像漂流瓶的感觉？像逃生舱的感觉？像时间胶囊的感觉？<br>反正就是想留下些什么，所以做个记录。不可能像那些有名的作者、摄影师、画家，也成为不了什么开创哪个学科和理论的科学家，就当一个只会闲言碎语的普通罗里吧嗦的陌生人就好了。不求对别人有用，但求记录真实。</p>
<h2 id="重庆"><a href="#重庆" class="headerlink" title="重庆"></a>重庆</h2><p>date：2017/4/2-4/6</p>
<p>这个应该是我第一次剪辑的视频，很兴致勃勃地拍了很多素材（每次拍素材都觉得自己是个导演）。然后兴致勃勃地记录很多很无聊的事情，然后兴致勃勃地第一次剪辑。<br>然后emmm不可避免的是，剪辑这回事实在是有点太费时间了，电脑又卡，翻过来翻过去音乐听了无数遍，最后把原来很喜欢的音乐给听的再也不想听。字幕也是，pr对新手有点太不友好啦。</p>
<iframe width="100%" height="350" src="//player.bilibili.com/player.html?aid=69298716&cid=120097937&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<h2 id="西安livehouse"><a href="#西安livehouse" class="headerlink" title="西安livehouse"></a>西安livehouse</h2><p>date: 2017/4/21</p>
<p>是yq同学约我去西安的一家livehouse里听崔开潮唱歌。当时做这个视频很有野心….就是自己人为的添加了一些自己觉得有趣的镜头和转场。朋友们看了一致认为那个中途晃得有点突然（我是想表现出一种镜头摇晃、自然过渡）。不过自己认为开头的几段留黑很酷，嘿嘿。</p>
<iframe width="100%" height="300" src="//player.bilibili.com/player.html?aid=69307930&cid=120118638&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<h2 id="北海道旅行"><a href="#北海道旅行" class="headerlink" title="北海道旅行"></a>北海道旅行</h2><p>date：2019/1/10-1/19</p>
<p>啊还是很想再去北海道看一次雪，其实这次有很多想看的想玩的地方都因为天气原因时间原因没有去，所以留了点遗憾。但是遗憾也算不上，因为肯定以后有机会还是会去的。陆陆续续改了好几个版本，最后剪出了这个版本（很多时候我都是热情退却后懒得再剪辑，就这样放着了）。不过，回想起来，2019的开头和大四的临近结束是已北海道作为记忆结点的，觉得这是件幸运的事。</p>
<iframe width="100%" height="330" src="//player.bilibili.com/player.html?aid=69295148&cid=120096190&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<h2 id="中秋欢乐纪实"><a href="#中秋欢乐纪实" class="headerlink" title="中秋欢乐纪实"></a>中秋欢乐纪实</h2><p>date：2019/9/14</p>
<p>这个剪辑是最不经心的一次，直接在手机上用imovie按时间顺序导入后生成的视频，imovie提供了很简单的音乐和音效，说实话剪辑过程不太自由，供选择的地方很少，但是很小白。然后在b站的在线编辑器里加了字幕，这个在线编辑器同样很适合新手，但是！添加完字幕后它直接就附在背景上了！就是如果你要修改文字，是不可以的？它不提供可持续性修改的自由，只是给你生成一个视频。而不是过程文件。就如果你要修改就得从头全部都要改很麻烦。<br>不过中秋啦，是暨黄鸡出国欢送会，黄鸡也在日本待了两个月了，有点想念她。不过我觉得，她一定会在哪里都过得快乐的！I promise.</p>
<iframe width="100%" height="340" src="//player.bilibili.com/player.html?aid=69287586&cid=120082292&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<h2 id="万圣节小记"><a href="#万圣节小记" class="headerlink" title="万圣节小记"></a>万圣节小记</h2><p>date：2019/10/31<br>越来越懒啦，被实验室的同学拖去参加了maolivehouse今年的万圣节活动。去之前兴致勃勃地画了一个自认为很浓的妆，到了之后发现自己输得彻底。我画的在那里就相当于没有。是很新奇的体验，但是一直没有找到喝酒的乐趣。所以喝了三罐可乐，人很多很挤，请来的乐队表演都很土嗨和迷幻，个人还是喜欢安安静静的livehouse，坐着抱一把吉他的那种。像台大旁边的女巫店一样的那种。不过也算是人生体验必须之一吧，毕竟要多多尝试新的事情，才能找到自己喜欢什么，不喜欢什么。</p>
<iframe width="100%" height="340" src="//player.bilibili.com/player.html?aid=75777873&cid=129633083&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/18/teach/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="whale">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HJ's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/18/teach/" itemprop="url">git与Visual Studio结合使用教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-18T21:00:14+08:00">
                2019-12-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="git与Visual-Studio结合使用教程"><a href="#git与Visual-Studio结合使用教程" class="headerlink" title="git与Visual Studio结合使用教程"></a>git与Visual Studio结合使用教程</h1><p>git是代码托管平台，用于团队合作的代码修改和开发。总结来说就是，提供一种可供大家共同开发大型代码项目的工具。</p>
<p>需要先安装git，具体安装教程网上有很多，可以自行搜索。<br>然后由于平时用的是visual studio code来开发代码，visual studio code里面也可以上传你修改的代码，下拉别人修改的代码。修改记录和他人的评论注释内容都可看到。</p>
<p><a name="ZtFoc"></a></p>
<h2 id="1-需要将你的代码和远程的respository建立联系"><a href="#1-需要将你的代码和远程的respository建立联系" class="headerlink" title="1.需要将你的代码和远程的respository建立联系"></a>1.需要将你的代码和远程的respository建立联系</h2><p>具体操作有两种。一种是coding（或者github）上有建立好的知识库，你将其代码下载到本地，在进行修改和开发；另一种是本地的代码，你想将它上传至coding，在进行修改和开发。<br><a name="h2mRW"></a></p>
<h3 id="下载到本地"><a href="#下载到本地" class="headerlink" title="下载到本地"></a>下载到本地</h3><ol>
<li>在自己的电脑上找个合适的位置存储代码，新建项目文件夹helloworld（推荐使用知识库的名字）</li>
<li>cd helloworld /进入项目文件夹</li>
<li>git init /初始化仓库</li>
<li>git remote add helloworld&lt;项目地址 就是平台上的url直接复制，记得左右这两个小标不需要，否则会出错&gt; /将远程知识库和此文件夹添加关联</li>
<li>git pull helloworld（仓库名）master（分支名）  /下载代码到本地</li>
</ol>
<p><a name="xTMzg"></a></p>
<h3 id="上传到coding等托管平台"><a href="#上传到coding等托管平台" class="headerlink" title="上传到coding等托管平台"></a>上传到coding等托管平台</h3><ol>
<li>在coding上创建一个新的项目helloworld，记录项目git都着急哦</li>
<li>cmd到项目的根目录，使用git init 创建.git文件夹和.gitigonore文件</li>
<li>git pull&lt;项目地址&gt; /同步项目上面的文件</li>
<li>git add* /添加项目下面的所有文件</li>
<li>git commit-m “对本次修改的备注”</li>
<li>git remote add&lt;仓库名&gt; ssh地址</li>
<li>git push-u helloworld（仓库名）master（分支名）/上传代码到平台 推送至coding</li>
</ol>
<p><a name="EbjsF"></a></p>
<h2 id="2-在Visual-Studio-Code里面"><a href="#2-在Visual-Studio-Code里面" class="headerlink" title="2.在Visual Studio Code里面"></a>2.在Visual Studio Code里面</h2><p>可以下载vs平台提供的专门用于代码管理的插件 GitLens<br>也可以直接使用终端，在终端输入命令行执行。<br>具体常用的命令行语句有 <br>git status 查看代码更改状态<br>git pull  /下拉知识库内容<br>git commit-m “注释内容” /对更改做一个简单的注释和评论<br>git push /将更改上传至知识库</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/Artop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="whale">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HJ's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/Artop/" itemprop="url">Artop</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T17:30:00+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Artop的调研"><a href="#Artop的调研" class="headerlink" title="Artop的调研"></a>Artop的调研</h1><p><a name="etzGX"></a></p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p><a name="hxOAv"></a></p>
<h3 id="1-1-权限"><a href="#1-1-权限" class="headerlink" title="1.1 权限"></a>1.1 权限</h3><p>Artop的使用的话只开放给Design Member（设计成员，是对用户组的策略和整体设计有重大影响），Contributing Member（对Artop做出贡献并参与Artop的技术内容）和Adopter（根据相应的Artop软件许可的规定免费使用，修改和构建Artop的一方。没有正式的流程可以成为Adopter，你可以从本网站下载并根据相应的Artop软件许可条款使用）。目前我们可以用学生的身份申请，但如果要基于它进行IDE的开发的话，肯定要成为User Group的成员。对AUTOSAR member和partner是免费开放的。</p>
<p><a name="cdvKe"></a></p>
<h3 id="1-2-功能"><a href="#1-2-功能" class="headerlink" title="1.2 功能"></a>1.2 功能</h3><p>Artop是用于设计和配置符合AUTOSAR标准的系统和ECU。基于Artop的完整AUTOSAR工具通常分为若干层，如下所示。 关于层的主要方面是Artop关注平台功能（蓝色）而不是最终用户功能（红色）。 最终用户功能是竞争层的一部分，不在Artop的范围内。 竞争层由工具供应商商业开发的专有插件组成。 此层上的插件使Artop适应最终用户需求并补充Artop的功能，以便工具供应商的产品满足最终用户的要求。在AUTOSAR工具的背景下，最终用户是直接参与基于AUTOSAR的系统或ECU开发的工程师。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/436186/1565527937142-fa5d22ee-0758-44c8-ba7a-ba383d8a72c3.png#align=left&display=inline&height=167&name=image.png&originHeight=167&originWidth=489&size=30559&status=done&width=489" alt="image.png"><br>Artop提供的主要组件包括：</p>
<ul>
<li>元模型实现和序列化</li>
<li>工作区管理</li>
<li>元模型扩展器</li>
<li>资源管理器和编辑</li>
<li>模型比较</li>
<li>模型验证</li>
<li>ECUC的代码生成基础设施</li>
</ul>
<p><strong>Artop有五个子项目——core、validation sub-project、ECU Configuration sub-project、ARText和ARUnit。</strong><br>**<br><a name="QunL6"></a></p>
<h2 id="2-1-Core"><a href="#2-1-Core" class="headerlink" title="2.1 Core"></a>2.1 Core</h2><p><a name="my4Oc"></a></p>
<h3 id="2-1-1-概述："><a href="#2-1-1-概述：" class="headerlink" title="2.1.1 概述："></a>2.1.1 概述：</h3><p>core包括元模型（ Meta Models）、序列化（Serialization）和工作区管理（Workspace Management）。<br>Artop的核心组件。主要包括AUTOSAR元模型实现以及与AUTOSAR模型实例一起使用所需的公共运行时服务。 这些运行时服务包括但不限于XML序列化，工作区管理，资源管理器和编辑器以及比较和合并。</p>
<p><a name="e4B9U"></a></p>
<h3 id="2-1-2-元模型和序列化"><a href="#2-1-2-元模型和序列化" class="headerlink" title="2.1.2 元模型和序列化"></a>2.1.2 元模型和序列化</h3><p>Artop为AUTOSAR的最新版本都提供了元模型实现，Artop为这些修订提供原生支持，修订均由转换器支持，转换器处理XML级别的修订之间的元模型微小变化。</p>
<p>元模型是<strong>EMF（Eclipse Modeling Framework）</strong>生成的代码。<br>gautosar（generic autosar）通用autosar元模型是位于具体元模型上方的图层，这意味着具体的元模型实现从gautosar层继承。gautosar层定义了一组接口，这些接口与所有元模型版本相同。<br>目前，gautosar层有三个元模型子集。</p>
<ul>
<li>基础设施（AUTOSAR对象，ARPackage，ArObject ……）</li>
<li>Ecuc参数定义</li>
<li>Ecuc描述<br>首先，您需要导入元模型生成项目集。 根据您使用的Subversion客户端插件，您需要导入MM Gen. Subversive项目集或MM Gen. Subclipse项目集。 gautosar图层由gautosar.ecore文件定义。<br>对元模型的操作都是先对gautosar进行操作：1.对gautosar层增加新的接口 2.对gautosar接口增加新的methods<br>具体操作细节见：<a href="https://www.artop.org/mediawiki/index.php?title=Meta_Models_%26_Serialization" target="_blank" rel="noopener">链接</a></li>
</ul>
<p><a name="KSym1"></a></p>
<h2 id="2-2-Validation-Sub-Project"><a href="#2-2-Validation-Sub-Project" class="headerlink" title="2.2 Validation Sub-Project"></a>2.2 Validation Sub-Project</h2><p>一个框架，提供验证加载的AUTOSAR和非AUTOSAR模型的功能。<br><a name="0MUXo"></a></p>
<h2 id="2-3-ECU-Configuration-Sub-Project"><a href="#2-3-ECU-Configuration-Sub-Project" class="headerlink" title="2.3 ECU Configuration Sub-Project"></a>2.3 ECU Configuration Sub-Project</h2><p>简称ECUC，包括ECU配置编辑器、生成器、向导和其他ECU配置相关的功能。</p>
<p>该子项目包含了一般实用程序的架构工作，规范和开发，以实现以下组件：</p>
<ul>
<li>ECU配置API生成：生成方便的API以使用ECU配置的机制，例如用于验证规则和代码生成。</li>
<li>用于基于标准模块定义或/和供应商特定模块定义创建模块配置文件的软件组件。</li>
<li>实施ECU配置特定验证规则。</li>
</ul>
<p><a name="PbVew"></a></p>
<h2 id="2-4-ARText"><a href="#2-4-ARText" class="headerlink" title="2.4 ARText"></a>2.4 ARText</h2><ol>
<li>ARText是Artop的子项目，是用于为AUTOSAR构建文本建模语言的框架。用来描述复杂系统的有效手段。ARText基于Xtext（Xtext是用来开发编程语言或领域专用语言的框架，可以定义语法）。ARText使用专门用于AUTOSAR领域的功能扩展Xtext，并在Artop中提供编辑器的完全集成。</li>
</ol>
<p>优点：</p>
<ul>
<li>ARText编辑器提供丰富的文本编辑环境，包括语法突出显示，代码完成，集成验证等。</li>
<li>与其他AUTOSAR资源无缝衔接。例如AUTOSAR XML。可以从ARText文件引用XML定义的实体，XML也可以引用ARText定义的实体。</li>
<li>支持标准AUTOSAR交换格式。可以讲ARText语言定义的AUTOSAR模型导出为XML.</li>
</ul>
<ol start="2">
<li>ARText已经有几种文本语言。SWC 语言，时序语言，公式语言（支持再AUTOSAR模型中指定和评估公式），变量语言。<br><a name="NPLb1"></a><h2 id="2-5-ARUnit"><a href="#2-5-ARUnit" class="headerlink" title="2.5 ARUnit"></a>2.5 ARUnit</h2>AUTOSAR软件组件的单元测试也是Artop的子项目。可在任何典型的基于Eclipse/Artop环境中运行。<br>ARUnit为AUTOSAR软件组件提供轻量级测试环境。 它……为在所有主要桌面平台上运行的单个软件组件生成RTE。 …提供API以从外部激发和查询RTE的状态。 …可以对特定的SWC功能进行有效和高效的单元测试。<blockquote>
<p>这个工具的原因是为了在开发周期中尽早进行连续且严格的测试过程，而且所有软件组件都需要在RTE内运行，为了生成功能齐全的标准的RTE。</p>
</blockquote>
</li>
</ol>
<p>主要功能为：为一个单独的软件组件生成功能齐全的，符合AUTOSAR标准的RTE。可以编译并与实际的软件组件代码连接，并在所有主要的桌面平台上运行。<strong>除了RTE接口的面向组件的一侧之外，ARUnit还生成公开可见的API，通过该API可以从外部监控和激励RTE的状态，即通常通过测试用例。<br></strong>但是！！！！它不模拟ECU或RTOS。没有可运行和任务的调度，因此对于更复杂的场景，您必须手动编排runnables的调用。由于ARUnit专注于单个软件组件的单元测试，因此我们目前不支持组合。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/436186/1565528319891-8b88dd26-7880-4956-8c27-553abef4663b.png#align=left&display=inline&height=276&name=image.png&originHeight=276&originWidth=437&size=24431&status=done&width=437" alt="image.png"><br>用来测试的公共API语法遵循与“内部”API相同的语法和名义约定，但所有函数名称都以ARUnit_而不是Rte_开头。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARUnit_Write_Calculator_AdditionInput_OperandA(summand1); ARUnit_Write_Calculator_AdditionInput_OperandB(summand2); </span><br><span class="line"> // call SWC runnable ARUnit_Trigger_Calculator_Cyclic();</span><br></pre></td></tr></table></figure>

<p>ARUnit还提供（基于模拟的测试方法）基于GMock的RTE实现，其中RTE调用被转发到GMocke的C ++类。<br>还提供扩展点以将自定义生成器挂载到生成过程中。因此可以提供额外的生成步骤，例如用C ++或Python生成RTE包装器API。<br>还提供可从命令行启动的单独生成器可执行文件。这允许与自动构建系统轻松集成。</p>
<p><a name="uAdAD"></a></p>
<h2 id="AAL教程"><a href="#AAL教程" class="headerlink" title="AAL教程"></a>AAL教程</h2><p>使用Model Loading Performance Status。</p>
<p><a name="z6tke"></a></p>
<h2 id="下载包释义："><a href="#下载包释义：" class="headerlink" title="下载包释义："></a>下载包释义：</h2><p><strong>Artop Technology Demonstrator：</strong> 是一组演示了底层平台的特性和功能的示例。是一个独立的应用程序，用于方便地浏览Artop而不需要现有地Eclipse。 <br>下载包 artop-demo<br><strong>Artop SDK：</strong>包含开发基于Artop插件所需的所有Artop插件。SDK还包含源代码和文档。<br>下载包：artop-sdk，artop-update，artop-examples，artop-runtime，<br><strong>ARText SDK：</strong>包含开发基于Artop的AUTOSAR文本语言所需的所有ARText插件以及当前的文本语言插件。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/09/c语言学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="whale">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HJ's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/09/c语言学习/" itemprop="url">C语言学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-09T16:25:02+08:00">
                2019-08-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a name="CyWxj"></a></p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>说明这变量可能会被意想不到改变，优化器用到时均会小心读取，而不是读取寄存器中的备份。<br>一般用在多线程程序中，以避免在其中一个线程操作该变量时，将其拷贝到寄存器。<br>例子：并行设备的硬件寄存器；中断程序中访问的非自动变量；多线程应用中被几个任务共享的变量。<br>_<br><a name="mEhIi"></a></p>
<h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><p>用来声明外部变量或外部函数。与<em><strong>static</strong>_关键词相对。在函数声明中，如果没有声明为</em><strong>static</strong>_静态变量，默认为extern，可以不用写明。<br>外部变量是指在函数或者文件外部定义的全局变量，必须在所有函数之外，且只能定义一次。声明了外部函数原型时，编译器会根据该原型自动从其他代码文件中查找到这个函数的定义，之后把这个函数扩展到所在文件中，就能调用了。<br>使用场景：当代码中包含外部函数原型时，有两种可能。</p>
<ol>
<li>编程人员希望编译器可以自动从其他文件中找到这个函数的定义；</li>
<li>编程人员先定义下来未实现的空函数，然后在其他的文件中具体实现。</li>
</ol>
<p>函数声明即：（返回类型） 函数名称（参数1类型 参数1，参数2类型 参数2，……）</p>
<p><a name="6HkoJ"></a></p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>常用于提高程序的模块化特性。<br>用来声明静态局部变量或静态函数。</p>
<ol>
<li>当声明变量时，声明时不赋值，自动默认为0。存储于进程的全局数据区，每次调用的初始值为上一次调用的值，调用结束后在存储空间不释放。在函数中声明一个<strong>static</strong>变量，则该变量在被调用过程中维持其值不变；在模块内（函数体外）声明一个<strong>static</strong>变量，则该变量能被模块内所有函数访问，但不能被模块外其他函数访问，它是一个本地的全局变量。</li>
<li>当声明函数时，则该函数只能被这一模块内的其他函数调用。与声明为<strong>extern</strong>的函数不同，不能被其他代码文件调用。</li>
</ol>
<p><a name="DUcmx"></a></p>
<h2 id="预编译指令"><a href="#预编译指令" class="headerlink" title="预编译指令"></a>预编译指令</h2><ul>
<li><p>*<em>#error  *</em></p>
<p>   预处理到#error将会停止编译并输出用户自定义的错误信息</p>
</li>
<li><p>*<em>#define *</em></p>
<pre><code>定义一个预处理宏，根据参数可分为对象宏和函数宏。</code></pre></li>
</ul>
<ol>
<li>常量定义        eg.#define MAX_LENGTH 100</li>
<li>通用标识        eg.#define SLOG printf</li>
<li>预编译宏        eg.#define _DEBUG</li>
<li>函数宏           eg.#define MIN(a,b) ((a)&gt;(b)?(a):(b))</li>
</ol>
<ul>
<li><p>*<em>#undef *</em></p>
<pre><code>取消宏的定义</code></pre></li>
<li><p><strong>#if</strong></p>
<p>   与#define 配合使用，判断某个宏是否被定义</p>
</li>
<li><p>*<em>#ifdef  *</em></p>
<p>   与#ifndef都是为了避免在多个文件中重复定义。如果定义了xx，就执行下一条语句。</p>
</li>
<li><p><strong>#ifndef</strong></p>
</li>
<li><p><strong>#elif</strong></p>
</li>
<li><p><strong>#else</strong></p>
</li>
<li><p>*<em>#endif  *</em></p>
<p>都是配合使用，为了避免重复定义。常见于大型的项目开发。</p>
</li>
</ul>
<p><a name="jiwvK"></a></p>
<h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><ul>
<li><strong>定义一种类型名</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char*a,b;\\只有a是指针   </span><br><span class="line">typedef char *PCHAR; \\可以看作PCHAR被定义成了指向字符的指针，在书写中最好*于PCHAR靠近，虽然char*这样的格式也是可以的，但在使用时容易引起歧义。</span><br><span class="line">PCHAR pa,pb;\\两者皆指针</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如果使用#define来创建新的类型名，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define PCHAR char*;</span><br><span class="line">PCHAR a,b;\\只有a被声明为了指向字符型的指针，b不是。因为define的作用只是单纯字符替换。所以有关于指针数组什么的还是用typedef合适。</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>用于struct结构体</strong></p>
</li>
<li><p><strong>跨平台移植</strong></p>
<p>程序编写中，如果考虑到平台移植的因素，则需要从代码中抽象出硬件层的差异，考虑到一个浮点型变量，在不同的硬件平台上，所占据的空间有可能不同，此时，可以采用typedef将其定义到单独的头文件里，该头文件全是硬件相关的内容。</p>
</li>
</ul>
<p><a name="s5fwv"></a></p>
<h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><p>用于内联函数。（如果亦谐函数被频繁调用，不断地有函数入栈，会造成栈空间的或栈内存地大量消耗，为了解决这个问题，用inline）<br>inline与函数定义体放在一起时，使其成为内联函数。在被调用时直接替换成代码，而不用函数栈。另外需要注意的是，只适合于代码简单的函数体使用，并且内联函数本身不能是直接递归函数。用于减少程序运行时的空间消耗，提高运行效率和速度。</p>
<p><a name="Il4Ve"></a></p>
<h2 id="switch（）"><a href="#switch（）" class="headerlink" title="switch（）"></a>switch（）</h2><p>switch语句很熟悉了，但是有一点需要注意的是case后不加break的话，那就会执行对应case后面的所有语句。case标签并不是把语句列表划分为几个部分，只是确定语句列表的进入点。</p>
<p><a name="ChwbM"></a></p>
<h2 id="memset（）"><a href="#memset（）" class="headerlink" title="memset（）"></a>memset（）</h2><p>原型为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern void*memset(void*buffer,int c,int count)</span><br></pre></td></tr></table></figure>

<p>buffer为指针或数组，c是赋给buffer的值，count是buffer的长度。<br><a name="yHa0L"></a></p>
<h2 id="memcpy（）"><a href="#memcpy（）" class="headerlink" title="memcpy（）"></a>memcpy（）</h2><p>内存拷贝函数 原型为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void*memcpy(void*destin,void*cource,unsigned n)</span><br></pre></td></tr></table></figure>

<p>从源source中拷贝n个字节到目标destin中。</p>
<p><a name="t0zn2"></a></p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>4种基本数据类型——整型、浮点型、指针和聚合类型（如数组和结构体等）。<br><strong>sint32 **有符号的32位整型<br></strong>（类型）数**  将数强制转换为括号内的类型。 <br>eg.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(int) 0.00;\\将0.00强制转换为int型的0.</span><br><span class="line">char a[20];     </span><br><span class="line">int *p=(int *)a;\\因为p指针指向的类型声明为int型，而a本身是字符型的数组，所以需要强制转换将其类型改为int型，但并不会改变数组a的内容。因为int型大小大于char型。</span><br></pre></td></tr></table></figure>

<p><a name="cfKuy"></a></p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>变量拥有三个属性——作用域、链接属性和存储类型。决定了一个变量可以在什么地方使用和它的值将保持多久。<br>当变量在程序的某个部分被声明时，它只有在程序的一定区域内才能被访问。</p>
<p><a name="byunj"></a></p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针是一个特殊的变量，其值为另一个变量的地址。像其他变量或常量一样，在使用指针存储其他变量地址之前，需要对其进行声明。格式为 type *var-name</p>
<p>需要弄清楚指针的四个概念：指针的类型，指针所指向的类型，指针的值或叫指针所指向的地址，指针本身占据的内存区。</p>
<p><a name="socrE"></a></p>
<h3 id="1-指针的类型"><a href="#1-指针的类型" class="headerlink" title="1.指针的类型"></a>1.指针的类型</h3><p>将指针声明语句里指针名字去掉，剩下的部分就是这个指针的类型。</p>
<p><a name="8TiHr"></a></p>
<h3 id="2-指针所指向的类型"><a href="#2-指针所指向的类型" class="headerlink" title="2.指针所指向的类型"></a>2.指针所指向的类型</h3><p>将指针声明语句中的指针名字和名字左边的指针声明符号*去掉，剩下的部分就是指针指向的类型。<br><a name="Bvbgf"></a></p>
<h3 id="3-指针指向的地址（重点）"><a href="#3-指针指向的地址（重点）" class="headerlink" title="3.指针指向的地址（重点）"></a>3.指针指向的地址（重点）</h3><p>指针的值是存储的数值，这个值被编译器认作一个地址，而不是一个单纯的数值。例如：在32位程序里，所有类型的指针的值都是一个32位整数，因为32位程序里内存地址全都是32位长。指针所指向的内存区是从指针的值所代表的内存地址开始，长度位sizeof（指针所指向的类型）的一片内存区。<br><a name="TQ6ek"></a></p>
<h3 id="4-指针本身占据的内存区"><a href="#4-指针本身占据的内存区" class="headerlink" title="4.指针本身占据的内存区"></a>4.指针本身占据的内存区</h3><p>指针本身占据的内存区大小，通过sizeof（指针类型）即可知道。在32位平台里，指针本身占据了4个字节的长度。跟系统有关。不怎么常用，但是在欧安段一个指针表达式是否是左值时很有用。</p>
<p><a name="Gj2UR"></a></p>
<h3 id="指针的算术运算"><a href="#指针的算术运算" class="headerlink" title="指针的算术运算"></a>指针的算术运算</h3><p>指针可以加上或减去一个整数，不过和普通的数值加减运算的意义是不一样的，以单元为单位。</p>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	char a[20] = &quot;you are a pig&quot;;</span><br><span class="line">	char *p = a;</span><br><span class="line">	char **ptr = &amp;p;</span><br><span class="line">	printf(&quot;%d\n&quot;, sizeof(char **));</span><br><span class="line">	printf(&quot;p=%d\n&quot;, p);</span><br><span class="line">	printf(&quot;ptr=%d\n&quot;, ptr);</span><br><span class="line">	printf(&quot;*ptr=%d\n&quot;, *ptr);</span><br><span class="line">	printf(&quot;**ptr=%c\n&quot;, **ptr);</span><br><span class="line">	ptr++;</span><br><span class="line">	printf(&quot;p=%d\n&quot;, p);</span><br><span class="line">	printf(&quot;ptr=%d\n&quot;, ptr);</span><br><span class="line">	printf(&quot;*ptr=%d\n&quot;, *ptr);</span><br><span class="line">	printf(&quot;**ptr=%c\n&quot;, **ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后输出为：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/436186/1565163444862-bd713224-8f2e-4189-8fe7-65714263d2ab.png#align=left&display=inline&height=150&name=image.png&originHeight=150&originWidth=183&size=3373&status=done&width=183" alt="image.png"></p>
<p>分析：上面的例子中，p的指针类型为 char<em>，p所指向的类型为char，p所指向的地址为数组a的首地址（在C语言中，几乎在所有使用数组的表达式中，数组名的值是一个指针常量，也就是数组第一个元素的地址。）（*</em>但注意：在两种场合下，数组名不是指针常量的意义。就是当数组名作为sizeof操作符和单目操作符&amp;的操作数时。sizeof（a）返回整个数组的长度，而不是指向数组首地址的指针的长度。&amp;a，取一个数组名的地址所产生的是一个指向数组的指针，而不是一个指向某个指针常量的指针。）<strong><br>ptr的指针类型为char</strong>，ptr所指向的类型为char<em>（ptr为二级指针，指向一个字符型指针），ptr所指向的地址为指针p的地址。p和ptr本身占据的内存区大小通过sizeof命令输出为4，说明本系统内char型指针本身大小为4个字节。所以</em>ptr就是p的地址，**ptr就是p指向的数组a的地址。</p>
<p><em><strong>注意：</strong></em><br>除了数组名的值可作为一个指针常量之外，当字符串常量出现在一个表达式中时，表达式所使用的值就是这些字符所存储的地址，而不是字符本身。<br>eg.char *message=”Hello World!”;<br>就是声明了一个指向字符类型的message指针，并初始化它的值使其指向”Hello World!”的首地址。<br></p>
<p><a name="GtCXW"></a></p>
<h3 id="指针运算符-amp-和"><a href="#指针运算符-amp-和" class="headerlink" title="指针运算符&amp;和*"></a>指针运算符&amp;和*</h3><p>&amp;是取地址运算符，*是间接运算符（指针指向结果值，对指针进行间接访问操作就可以获得这个值）。<br>C语言中，运算符优先级为</p>
<table>
<thead>
<tr>
<th align="left">优先级</th>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">结合性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><code>++</code> <code>--</code></td>
<td align="left">后缀自增与自减</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>()</code></td>
<td align="left">函数调用</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>[]</code></td>
<td align="left">数组下标</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>.</code></td>
<td align="left">结构体与联合体成员访问</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>-&gt;</code></td>
<td align="left">结构体与联合体成员通过指针访问</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>(_type_){_list_}</code></td>
<td align="left">复合字面量</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><code>++</code> <code>--</code></td>
<td align="left">前缀自增与自减</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>+</code> <code>-</code></td>
<td align="left">一元加与减</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>!</code> <code>~</code></td>
<td align="left">逻辑非与逐位非</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>(_type_)</code></td>
<td align="left">类型转型</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>*</code></td>
<td align="left">间接（解引用）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>&amp;</code></td>
<td align="left">取址</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>sizeof</code></td>
<td align="left">取大小<a href="https://zh.cppreference.com/w/c/language/operator_precedence#cite_note-2" target="_blank" rel="noopener">[注 2]</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>_Alignof</code></td>
<td align="left">对齐要求</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><code>*</code> <code>/</code> <code>%</code></td>
<td align="left">乘法、除法及余数</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><code>+</code> <code>-</code></td>
<td align="left">加法及减法</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><code>&lt;&lt;</code> <code>&gt;&gt;</code></td>
<td align="left">逐位左移及右移</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><code>&lt;</code> <code>&lt;=</code></td>
<td align="left">分别为 &lt; 与 ≤ 的关系运算符</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>&gt;</code> <code>&gt;=</code></td>
<td align="left">分别为 &gt; 与 ≥ 的关系运算符</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><code>==</code> <code>!=</code></td>
<td align="left">分别为 = 与 ≠ 关系</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><code>&amp;</code></td>
<td align="left">逐位与</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><code>^</code></td>
<td align="left">逐位异或（排除或）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">`</td>
<td align="left">`</td>
<td align="left">逐位或（包含或）</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><code>&amp;&amp;</code></td>
<td align="left">逻辑与</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">`</td>
<td align="left"></td>
<td align="left">`</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><code>?:</code></td>
<td align="left">三元条件</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><code>=</code></td>
<td align="left">简单赋值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>+=</code> <code>-=</code></td>
<td align="left">以和及差赋值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>*=</code> <code>/=</code> <code>%=</code></td>
<td align="left">以积、商及余数赋值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>&lt;&lt;=</code> <code>&gt;&gt;=</code></td>
<td align="left">以逐位左移及右移赋值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>&amp;=</code> <code>^=</code> `</td>
<td align="left">=`</td>
<td align="left">以逐位与、异或及或赋值</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><code>,</code></td>
<td align="left">逗号</td>
<td align="left">从左到右</td>
</tr>
</tbody></table>
<p><a name="p127d"></a></p>
<h3 id="常量与指针"><a href="#常量与指针" class="headerlink" title="常量与指针"></a>常量与指针</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int *pi;\\pi是一个普通的指向整型的指针</span><br><span class="line">int const *pi;\\pi指向整型常量，你可以修改指针，但不能修改它指向的值</span><br><span class="line">int *const pi;\\pi为指向整型的常量指针，你可以修改它指向的值，但它的值无法修改（即该指针存储的内存区域，门牌号）</span><br><span class="line">int const *const pi;\\pi为指向整型常量的常量指针。它的值无法修改，它指向的值也无法修改。</span><br></pre></td></tr></table></figure>

<p><a name="0b3xI"></a></p>
<h3 id="数组与指针"><a href="#数组与指针" class="headerlink" title="数组与指针"></a>数组与指针</h3><p>数组的数组名在很多情况下可以看作一个指针常量。</p>
<p>在AUTOSAR项目代码中，经常遇到的关于指针与数组的结构如下，对其进行简要的分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef Rte_CDS_x const * const Rte_Instance;</span><br><span class="line">typedef struct &#123;</span><br><span class="line">Rte_DE_xImpl * const x;\\Rte_DE_xImpl是一个有一个uint32类型的value的结构体。</span><br><span class="line">Rte_PDS_x_R PwmSet;</span><br><span class="line">Rte_PDS_x_R PwmSetDuty;</span><br><span class="line">&#125; Rte_CDS_x;</span><br><span class="line">typedef struct &#123;</span><br><span class="line">Std_ReturnType (*Call_Write)(/*IN*/DutyCycle DutyValue, /*OUT*/IoHwAb_StatusType * Status);</span><br><span class="line">&#125; Rte_PDS_x_R;</span><br><span class="line">typedef struct &#123;</span><br><span class="line">uint8 _dummy;</span><br><span class="line">&#125; Rte_PDS_x_R;</span><br></pre></td></tr></table></figure>

<p><a name="qkOHO"></a></p>
<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>标准中定义了几个<strong>三字母词（trigrph）</strong>，就是几个字符的序列，合起来表示另一个字符。通常用两个问号开头再尾随一个字符。<br>??(   [<br>??)   ]<br>??!   |<br>等等。<br>另外转义序列由一个反斜杠\加上一或多个其他字符组成。使其只代表字符而不是环境中的特殊含义，如\用来表示一个反斜杠。</p>
<p><a name="aYme9"></a></p>
<h2 id="读取输入的操作"><a href="#读取输入的操作" class="headerlink" title="读取输入的操作"></a>读取输入的操作</h2><p>C语言中，常用的用来从键盘获取用户输入的函数有：<br><strong>scanf()</strong>，可用来输入多种类型的数据<br><strong>getchar(),getche(),getch()，</strong>都用于输入单个字符,getchar()函数从标准输入读取一个字符并返回它的值。如果输入中不再存在任何字符，函数就会返回常量EOF（在stdio.h中定义），用于提示文件的结尾。<br><strong>gets()，</strong>从标准输入读取一行文本并把它存储于作为参数传递给它的数组中。一行输入由一串字符组成，以一个换行符结尾。gets函数丢弃换行符，并在该行的末尾存储一个NUL字节（NUL字节是指字节模式为全0的字节,’\0’），然后，gets函数返回一个非NULL值，表示该行被成功读取。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/05/linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="whale">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HJ's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/05/linux/" itemprop="url">Linux</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-05T16:25:02+08:00">
                2019-08-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p><a name="8Qzm3"></a></p>
<h1 id="Linux编译问题"><a href="#Linux编译问题" class="headerlink" title="Linux编译问题"></a>Linux编译问题</h1><p>由于AUTOSAR代码文件较多，所以运用Linux的make命令编译较为快捷。将代码在linux下编译完成后，将生成的可执行文件传回window系统烧写入单片机。整个编译流程，需要经历三个过程。将windows的代码文件传到linux上，在linux系统里编译，将编译完成的可执行文件重新传回windows系统。</p>
<p><a name="A85EL"></a></p>
<h2 id="1-windows系统与虚拟机linux间的文件互传"><a href="#1-windows系统与虚拟机linux间的文件互传" class="headerlink" title="1.windows系统与虚拟机linux间的文件互传"></a>1.windows系统与虚拟机linux间的文件互传</h2><p>windows系统与ubuntu虚拟机之间的文件互传有多种方式。</p>
<ul>
<li><strong>直接通过u盘拷贝。</strong>先使用fdisk-l命令查看U盘是否被识别到，且识别到哪个位置；在mnt中建立一个usb（随意命名）的文件夹；然后挂载到其识别到的U盘位置。就可以将U盘中的文件在linux下使用了。</li>
<li><strong>通过软件传输。</strong>在linux下下载一些专门用来传文件的软件即可。</li>
<li><strong>通过共享文件夹。</strong>通过设置虚拟机里面的共享文件夹，实现两个系统之间的互传。<br>打开VMware，然后在菜单栏的虚拟机设置中，选择选项，启用共享文件夹。并在windows系统下创建一个文件夹（任意位置）作为共享文件夹并添加；然后将该共享文件夹挂载到mnt上，一般共享的文件夹默认在/mnt/hgfs路径下。<br>   如果在hgfs目录中看不到共享文件夹，可能是没有安装VMware Tools。直接在VMware 虚拟机中的应用程序菜单中，点击安装VMware Tools安装即可。然后在图形化界面对共享文件夹的文件进行操作就可以了，右键需要传输的文件 用move to或copy to将其传到共享文件夹里就两个系统可共同访问。（Q：用cp命令将文件复制到共享文件夹的时候，会出现 fuse：mountpoint is not empty fuse： if you are sure this is safe, use the ‘nonempty’ mount option。不知道什么原因）</li>
</ul>
<p><a name="bLy46"></a></p>
<h2 id="2-linux下的make命令编译"><a href="#2-linux下的make命令编译" class="headerlink" title="2.linux下的make命令编译"></a>2.linux下的make命令编译</h2><p>make是一个非常重要的编译工具，尤其是应用在大型的开发项目。可将其分解为多个更易于管理的模块，对于一个包括几百个源文件的应用程序，可以通过make和makefile处理各个源文件之间的相互关系。make命令会去搜寻当前目录下的makefile文件，makefile文件主要用来描述各个文件之间的依赖与相互关系，整个工程所有文件的编译顺序和编译规则。makefile的编写是make正常工作的基础。make是一个命令工具，解释makefile中的规则。<br>makefile的格式：  target……：prequisites……<br>                 command<br>    另外为了便于维护，在makefile中我们可以使用变量（可理解为C语言中的宏）   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objects=main.o command.o</span><br></pre></td></tr></table></figure>

<p>$(object)就可以使用这个变量的内容。</p>
<pre><code>根据makefile文件的不同，全部编译的格式也会不同。autosar项目中使用的是：make BOARDDIR=stm32_stm3210c BDIR=../examples/xx/xx all</code></pre><p>需要注意的是make命令要在最顶层的makefile文件所在的目录下运行，否则会出错。<br>编译成功后会生成obj的目标文件夹，里面有elf，s19，hex等格式的可执行文件。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">whale</p>
              <p class="site-description motion-element" itemprop="description">suda masaki hahaha</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">whale</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
