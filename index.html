<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="[layout]-test" class="article article-type-[layout]" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/05/test/" class="article-date">
  <time datetime="2019-08-05T08:25:02.000Z" itemprop="datePublished">2019-08-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/05/test/">Linux</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p><a name="8Qzm3"></a></p>
<h1 id="Linux编译问题"><a href="#Linux编译问题" class="headerlink" title="Linux编译问题"></a>Linux编译问题</h1><p>由于AUTOSAR代码文件较多，所以运用Linux的make命令编译较为快捷。将代码在linux下编译完成后，将生成的可执行文件传回window系统烧写入单片机。整个编译流程，需要经历三个过程。将windows的代码文件传到linux上，在linux系统里编译，将编译完成的可执行文件重新传回windows系统。</p>
<p><a name="A85EL"></a></p>
<h2 id="1-windows系统与虚拟机linux间的文件互传"><a href="#1-windows系统与虚拟机linux间的文件互传" class="headerlink" title="1.windows系统与虚拟机linux间的文件互传"></a>1.windows系统与虚拟机linux间的文件互传</h2><p>windows系统与ubuntu虚拟机之间的文件互传有多种方式。</p>
<ul>
<li><p><strong>直接通过u盘拷贝。</strong>先使用fdisk-l命令查看U盘是否被识别到，且识别到哪个位置；在mnt中建立一个usb（随意命名）的文件夹；然后挂载到其识别到的U盘位置。就可以将U盘中的文件在linux下使用了。</p>
</li>
<li><p><strong>通过软件传输。</strong>在linux下下载一些专门用来传文件的软件即可。</p>
</li>
<li><p><strong>通过共享文件夹。</strong>通过设置虚拟机里面的共享文件夹，实现两个系统之间的互传。</p>
<pre><code>打开VMware，然后在菜单栏的虚拟机设置中，选择选项，启用共享文件夹。并在windows系统下创建一个文件夹（任意位置）作为共享文件夹并添加；然后将该共享文件夹挂载到mnt上，一般共享的文件夹默认在/mnt/hgfs路径下。&lt;br /&gt;     如果在hgfs目录中看不到共享文件夹，可能是没有安装VMware Tools。直接在VMware 虚拟机中的应用程序菜单中，点击安装VMware Tools安装即可。&lt;br /&gt;    然后在图形化界面对共享文件夹的文件进行操作就可以了，右键需要传输的文件 用move to或copy to将其传到共享文件夹里就两个系统可共同访问。（Q：用cp命令将文件复制到共享文件夹的时候，会出现 fuse：mountpoint is not empty fuse： if you are sure this is safe, use the &apos;nonempty&apos; mount option。不知道什么原因）</code></pre></li>
</ul>
<p><a name="bLy46"></a></p>
<h2 id="2-linux下的make命令编译"><a href="#2-linux下的make命令编译" class="headerlink" title="2.linux下的make命令编译"></a>2.linux下的make命令编译</h2><pre><code>make是一个非常重要的编译工具，尤其是应用在大型的开发项目。可将其分解为多个更易于管理的模块，对于一个包括几百个源文件的应用程序，可以通过make和makefile处理各个源文件之间的相互关系。&lt;br /&gt;make命令会去搜寻当前目录下的makefile文件，makefile文件主要用来描述各个文件之间的依赖与相互关系，整个工程所有文件的编译顺序和编译规则。makefile的编写是make正常工作的基础。make是一个命令工具，解释makefile中的规则。&lt;br /&gt;makefile的格式：  target……：prequisites……&lt;br /&gt;                            command&lt;br /&gt;     另外为了便于维护，在makefile中我们可以使用变量（可理解为C语言中的宏）&lt;br /&gt;   </code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objects=main.o command.o</span><br></pre></td></tr></table></figure>

<p>$(object)就可以使用这个变量的内容。</p>
<pre><code>根据makefile文件的不同，全部编译的格式也会不同。autosar项目中使用的是：&lt;br /&gt;make BOARDDIR=stm32_stm3210c BDIR=../examples/xx/xx all&lt;br /&gt;需要注意的是make命令要在最顶层的makefile文件所在的目录下运行，否则会出错。&lt;br /&gt;编译成功后会生成obj的目标文件夹，里面有elf，s19，hex等格式的可执行文件。</code></pre><p>##C++学习（1）</p>
<p>1.后缀名告诉系统这个文件为C++程序。C++最常见的后缀名为.cc,.cpp,.cxx,.C。<br>2.<strong>用cmd运行编译器操作</strong> 假设程序保存在prog1.cc内</p>
<p>‘’’<br>$ CC prog1.cc<br>‘’’</p>
<p>生成一个可执行文件，windows命名为prog.exe，UNIX命名为prog.out。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/05/test/" data-id="cjz144tg30000kct94wmdgasy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="[layout]-title" class="article article-type-[layout]" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/04/title/" class="article-date">
  <time datetime="2019-08-04T08:25:02.000Z" itemprop="datePublished">2019-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/04/title/">C语言学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a name="CyWxj"></a></p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>说明这变量可能会被意想不到改变，优化器用到时均会小心读取，而不是读取寄存器中的备份。<br>一般用在多线程程序中，以避免在其中一个线程操作该变量时，将其拷贝到寄存器。<br>例子：并行设备的硬件寄存器；中断程序中访问的非自动变量；多线程应用中被几个任务共享的变量。<br>_<br><a name="mEhIi"></a></p>
<h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a><em>extern</em></h2><p>用来声明外部变量或外部函数。与<em><strong>static</strong>_关键词相对。在函数声明中，如果没有声明为</em><strong>static</strong>_静态变量，默认为extern，可以不用写明。<br>外部变量是指在函数或者文件外部定义的全局变量，必须在所有函数之外，且只能定义一次。声明了外部函数原型时，编译器会根据该原型自动从其他代码文件中查找到这个函数的定义，之后把这个函数扩展到所在文件中，就能调用了。<br>使用场景：当代码中包含外部函数原型时，有两种可能。</p>
<ol>
<li>编程人员希望编译器可以自动从其他文件中找到这个函数的定义；</li>
<li>编程人员先定义下来未实现的空函数，然后在其他的文件中具体实现。</li>
</ol>
<p>函数声明即：（返回类型） 函数名称（参数1类型 参数1，参数2类型 参数2，……）</p>
<p><a name="6HkoJ"></a></p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>常用于提高程序的模块化特性。<br>用来声明静态局部变量或静态函数。</p>
<ol>
<li>当声明变量时，声明时不赋值，自动默认为0。存储于进程的全局数据区，每次调用的初始值为上一次调用的值，调用结束后在存储空间不释放。在函数中声明一个<strong>static</strong>变量，则该变量在被调用过程中维持其值不变；在模块内（函数体外）声明一个<strong>static</strong>变量，则该变量能被模块内所有函数访问，但不能被模块外其他函数访问，它是一个本地的全局变量。</li>
<li>当声明函数时，则该函数只能被这一模块内的其他函数调用。与声明为<strong>extern</strong>的函数不同，不能被其他代码文件调用。</li>
</ol>
<p><a name="DUcmx"></a></p>
<h2 id="预编译指令"><a href="#预编译指令" class="headerlink" title="预编译指令"></a>预编译指令</h2><ul>
<li><p><strong>#error</strong></p>
<p>   预处理到#error将会停止编译并输出用户自定义的错误信息</p>
</li>
<li><p><strong>#define</strong></p>
<pre><code>定义一个预处理宏，根据参数可分为对象宏和函数宏。</code></pre></li>
</ul>
<ol>
<li>常量定义        eg.#define MAX_LENGTH 100</li>
<li>通用标识        eg.#define SLOG printf</li>
<li>预编译宏        eg.#define _DEBUG</li>
<li>函数宏           eg.#define MIN(a,b) ((a)&gt;(b)?(a):(b))</li>
</ol>
<ul>
<li><p><strong>#undef</strong></p>
<pre><code>取消宏的定义</code></pre></li>
<li><p><strong>#if</strong></p>
<p>   与#define 配合使用，判断某个宏是否被定义</p>
</li>
<li><p><strong>#ifdef</strong></p>
<p>   与#ifndef都是为了避免在多个文件中重复定义。如果定义了xx，就执行下一条语句。</p>
</li>
<li><p><strong>#ifndef</strong></p>
</li>
<li><p><strong>#elif</strong></p>
</li>
<li><p><strong>#else</strong></p>
</li>
<li><p><strong>#endif</strong></p>
<p>都是配合使用，为了避免重复定义。常见于大型的项目开发。</p>
</li>
</ul>
<p><a name="jiwvK"></a></p>
<h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><ol>
<li><p>定义一种类型名  eg. char*a,b;\只有a是指针   </p>
<pre><code>typedef char*PCHAR;&lt;br /&gt;                                    PCHAR pa,pb;\\两者皆指针&lt;br /&gt;2.用于struct结构体&lt;br /&gt;3.跨平台移植&lt;br /&gt;  程序编写中，如果考虑到平台移植的因素，则需要从代码中抽象出硬件层的差异，考虑到一个浮点型变量，在不同的硬件平台上，所占据的空间有可能不同，此时，可以采用typedef将其定义到单独的头文件里，该头文件全是硬件相关的内容。</code></pre></li>
</ol>
<p><a name="s5fwv"></a></p>
<h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><p>用于内联函数。（如果亦谐函数被频繁调用，不断地有函数入栈，会造成栈空间的或栈内存地大量消耗，为了解决这个问题，用inline）<br>inline与函数定义体放在一起时，使其成为内联函数。在被调用时直接替换成代码，而不用函数栈。另外需要注意的是，只适合于代码简单的函数体使用，并且内联函数本身不能是直接递归函数。用于减少程序运行时的空间消耗，提高运行效率和速度。</p>
<p><a name="ChwbM"></a></p>
<h2 id="memset（）"><a href="#memset（）" class="headerlink" title="memset（）"></a>memset（）</h2><p>原型为extern void<em>memset(void</em>buffer,int c,int count)<br>buffer为指针或数组，c是赋给buffer的值，count是buffer的长度。<br><a name="yHa0L"></a></p>
<h2 id="memcpy（）"><a href="#memcpy（）" class="headerlink" title="memcpy（）"></a>memcpy（）</h2><p>内存拷贝函数 原型为 void<em>memcpy(void</em>destin,void*cource,unsigned n)<br>从源source中拷贝n个字节到目标destin中。</p>
<p><a name="t0zn2"></a></p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><strong>sint32 **有符号的32位整型<br></strong>（类型）数**  将数强制转换为括号内的类型。 eg.(int) 0.00 将0.00强制转换为int型的0.</p>
<p><a name="byunj"></a></p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针是一个特殊的变量，其值为另一个变量的地址。像其他变量或常量一样，在使用指针存储其他变量地址之前，需要对其进行声明。格式为 type *var-name</p>
<p>需要弄清楚指针的四个概念：指针的类型，指针所指向的类型，指针的值或叫指针所指向的地址，指针本身占据的内存区。</p>
<p><a name="socrE"></a></p>
<h3 id="1-指针的类型"><a href="#1-指针的类型" class="headerlink" title="1.指针的类型"></a>1.指针的类型</h3><p>将指针声明语句里指针名字去掉，剩下的部分就是这个指针的类型。</p>
<p><a name="8TiHr"></a></p>
<h3 id="2-指针所指向的类型"><a href="#2-指针所指向的类型" class="headerlink" title="2.指针所指向的类型"></a>2.指针所指向的类型</h3><p>将指针声明语句中的指针名字和名字左边的指针声明符号*去掉，剩下的部分就是指针指向的类型。<br><a name="Bvbgf"></a></p>
<h3 id="3-指针指向的地址（重点）"><a href="#3-指针指向的地址（重点）" class="headerlink" title="3.指针指向的地址（重点）"></a>3.指针指向的地址（重点）</h3><p>指针的值是存储的数值，这个值被编译器认作一个地址，而不是一个单纯的数值。例如：在32位程序里，所有类型的指针的值都是一个32位整数，因为32位程序里内存地址全都是32位长。指针所指向的内存区是从指针的值所代表的内存地址开始，长度位sizeof（指针所指向的类型）的一片内存区。<br><a name="TQ6ek"></a></p>
<h3 id="4-指针本身占据的内存区"><a href="#4-指针本身占据的内存区" class="headerlink" title="4.指针本身占据的内存区"></a>4.指针本身占据的内存区</h3><p>指针本身占据的内存区大小，通过sizeof（指针类型）即可知道。在32位平台里，指针本身占据了4个字节的长度。跟系统有关。不怎么常用，但是在欧安段一个指针表达式是否是左值时很有用。</p>
<p><a name="Gj2UR"></a></p>
<h3 id="指针的算术运算"><a href="#指针的算术运算" class="headerlink" title="指针的算术运算"></a>指针的算术运算</h3><p>指针可以加上或减去一个整数，不过和普通的数值加减运算的意义是不一样的，以单元为单位。</p>
<p>举例：</p>
<blockquote>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
</blockquote>
<blockquote>
<p>int main()</p>
</blockquote>
<blockquote>
<p>{</p>
</blockquote>
<blockquote>
<pre><code>char a[20] = &quot;you are a pig&quot;;</code></pre></blockquote>
<blockquote>
<pre><code>char *p = a;</code></pre></blockquote>
<blockquote>
<pre><code>char **ptr = &amp;p;</code></pre></blockquote>
<blockquote>
<pre><code>printf(&quot;%d\n&quot;, sizeof(char **));</code></pre></blockquote>
<blockquote>
<pre><code>printf(&quot;p=%d\n&quot;, p);</code></pre></blockquote>
<blockquote>
<pre><code>printf(&quot;ptr=%d\n&quot;, ptr);</code></pre></blockquote>
<blockquote>
<pre><code>printf(&quot;*ptr=%d\n&quot;, *ptr);</code></pre></blockquote>
<blockquote>
<pre><code>printf(&quot;**ptr=%c\n&quot;, **ptr);</code></pre></blockquote>
<blockquote>
<pre><code>ptr++;</code></pre></blockquote>
<blockquote>
<pre><code>printf(&quot;p=%d\n&quot;, p);</code></pre></blockquote>
<blockquote>
<pre><code>printf(&quot;ptr=%d\n&quot;, ptr);</code></pre></blockquote>
<blockquote>
<pre><code>printf(&quot;*ptr=%d\n&quot;, *ptr);</code></pre></blockquote>
<blockquote>
<pre><code>printf(&quot;**ptr=%c\n&quot;, **ptr);</code></pre></blockquote>
<blockquote>
<p>}</p>
</blockquote>
<p>运行后输出为：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/436186/1565163444862-bd713224-8f2e-4189-8fe7-65714263d2ab.png#align=left&display=inline&height=150&name=image.png&originHeight=150&originWidth=183&size=3373&status=done&width=183" alt="image.png"></p>
<p>分析：上面的例子中，p的指针类型为 char<em>，p所指向的类型为char，p所指向的地址为数组a的首地址（在C语言中，几乎在所有使用数组的表达式中，数组名的值是一个指针常量，也就是数组第一个元素的地址。）（*</em>但注意：在两种场合下，数组名不是指针常量的意义。就是当数组名作为sizeof操作符和单目操作符&amp;的操作数时。sizeof（a）返回整个数组的长度，而不是指向数组首地址的指针的长度。&amp;a，取一个数组名的地址所产生的是一个指向数组的指针，而不是一个指向某个指针常量的指针。）<strong><br>ptr的指针类型为char</strong>，ptr所指向的类型为char<em>（ptr为二级指针，指向一个字符型指针），ptr所指向的地址为指针p的地址。p和ptr本身占据的内存区大小通过sizeof命令输出为4，说明本系统内char型指针本身大小为4个字节。所以</em>ptr就是p的地址，**ptr就是p指向的数组a的地址。</p>
<p><a name="GtCXW"></a></p>
<h3 id="指针运算符-amp-和"><a href="#指针运算符-amp-和" class="headerlink" title="指针运算符&amp;和*"></a>指针运算符&amp;和*</h3><p>&amp;是取地址运算符，*是间接运算符。<br>C语言中，运算符优先级为</p>
<table>
<thead>
<tr>
<th align="left">优先级</th>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">结合性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><code>++</code> <code>--</code></td>
<td align="left">后缀自增与自减</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>()</code></td>
<td align="left">函数调用</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>[]</code></td>
<td align="left">数组下标</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>.</code></td>
<td align="left">结构体与联合体成员访问</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>-&gt;</code></td>
<td align="left">结构体与联合体成员通过指针访问</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>(_type_){_list_}</code></td>
<td align="left">复合字面量</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><code>++</code> <code>--</code></td>
<td align="left">前缀自增与自减</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>+</code> <code>-</code></td>
<td align="left">一元加与减</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>!</code> <code>~</code></td>
<td align="left">逻辑非与逐位非</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>(_type_)</code></td>
<td align="left">类型转型</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>*</code></td>
<td align="left">间接（解引用）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>&amp;</code></td>
<td align="left">取址</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>sizeof</code></td>
<td align="left">取大小<a href="https://zh.cppreference.com/w/c/language/operator_precedence#cite_note-2" target="_blank" rel="noopener">[注 2]</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>_Alignof</code></td>
<td align="left">对齐要求</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><code>*</code> <code>/</code> <code>%</code></td>
<td align="left">乘法、除法及余数</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><code>+</code> <code>-</code></td>
<td align="left">加法及减法</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><code>&lt;&lt;</code> <code>&gt;&gt;</code></td>
<td align="left">逐位左移及右移</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><code>&lt;</code> <code>&lt;=</code></td>
<td align="left">分别为 &lt; 与 ≤ 的关系运算符</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>&gt;</code> <code>&gt;=</code></td>
<td align="left">分别为 &gt; 与 ≥ 的关系运算符</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><code>==</code> <code>!=</code></td>
<td align="left">分别为 = 与 ≠ 关系</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><code>&amp;</code></td>
<td align="left">逐位与</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><code>^</code></td>
<td align="left">逐位异或（排除或）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">`</td>
<td align="left">`</td>
<td align="left">逐位或（包含或）</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><code>&amp;&amp;</code></td>
<td align="left">逻辑与</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">`</td>
<td align="left"></td>
<td align="left">`</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><code>?:</code></td>
<td align="left">三元条件</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><code>=</code></td>
<td align="left">简单赋值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>+=</code> <code>-=</code></td>
<td align="left">以和及差赋值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>*=</code> <code>/=</code> <code>%=</code></td>
<td align="left">以积、商及余数赋值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>&lt;&lt;=</code> <code>&gt;&gt;=</code></td>
<td align="left">以逐位左移及右移赋值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>&amp;=</code> <code>^=</code> `</td>
<td align="left">=`</td>
<td align="left">以逐位与、异或及或赋值</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><code>,</code></td>
<td align="left">逗号</td>
<td align="left">从左到右</td>
</tr>
</tbody></table>
<p><a name="0b3xI"></a></p>
<h3 id="数组与指针"><a href="#数组与指针" class="headerlink" title="数组与指针"></a>数组与指针</h3><p>数组的数组名在很多情况下可以看作一个指针常量。</p>
<p>在AUTOSAR项目代码中，经常遇到的关于指针与数组的结构如下，对其进行简要的分析：</p>
<p>typedef Rte_CDS_x const * const Rte_Instance;</p>
<p>typedef struct {<br>Rte_DE_xImpl * const x;\Rte_DE_xImpl是一个有一个uint32类型的value的结构体。<br>Rte_PDS_x_R PwmSet;<br>Rte_PDS_x_R PwmSetDuty;<br>} Rte_CDS_x;</p>
<p>typedef struct {<br>Std_ReturnType (<em>Call_Write)(/*IN</em>/DutyCycle DutyValue, /<em>OUT</em>/IoHwAb_StatusType * Status);<br>} Rte_PDS_x_R;</p>
<p>typedef struct {<br>uint8 _dummy;<br>} Rte_PDS_x_R;</p>
<p><a name="qkOHO"></a></p>
<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>标准中定义了几个<strong>三字母词（trigrph）</strong>，就是几个字符的序列，合起来表示另一个字符。通常用两个问号开头再尾随一个字符。<br>??(   [<br>??)   ]<br>??!   |<br>等等。<br>另外转义序列由一个反斜杠\加上一或多个其他字符组成。使其只代表字符而不是环境中的特殊含义，如\用来表示一个反斜杠。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/04/title/" data-id="cjz144tgx0002kct9sn5563kd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/30/hello-world/" class="article-date">
  <time datetime="2019-07-30T07:02:37.868Z" itemprop="datePublished">2019-07-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/30/hello-world/">test</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/30/hello-world/" data-id="cjz144tgb0001kct9f2f8z75k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/05/test/">Linux</a>
          </li>
        
          <li>
            <a href="/2019/08/04/title/">C语言学习笔记</a>
          </li>
        
          <li>
            <a href="/2019/07/30/hello-world/">test</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>